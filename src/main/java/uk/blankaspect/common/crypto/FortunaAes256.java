/*====================================================================*\

FortunaAes256.java

Class: Fortuna/AES-256 pseudo-random number generator.

\*====================================================================*/


// PACKAGE


package uk.blankaspect.common.crypto;

//----------------------------------------------------------------------


// IMPORTS


import java.util.Arrays;

//----------------------------------------------------------------------


// CLASS: FORTUNA/AES-256 PSEUDO-RANDOM NUMBER GENERATOR


/**
 * This class implements the Fortuna pseudo-random number generator (PRNG) algorithm, using an AES-256 block cipher
 * running in counter mode as the underlying generator.
 */

public class FortunaAes256
	extends Fortuna
	implements Cloneable
{

////////////////////////////////////////////////////////////////////////
//  Constants
////////////////////////////////////////////////////////////////////////

	/** The size (in bytes) of the PRNG's key, which is the key size of the AES-256 cipher. */
	public static final	int	KEY_SIZE	= Aes256.KEY_SIZE;

////////////////////////////////////////////////////////////////////////
//  Instance variables
////////////////////////////////////////////////////////////////////////

	private	Aes256	cipher;
	private	byte[]	counter;

////////////////////////////////////////////////////////////////////////
//  Constructors
////////////////////////////////////////////////////////////////////////

	/**
	 * Creates a Fortuna/AES-256 pseudo-random number generator that is initialised with a random seed derived from the
	 * sources of entropy.
	 * <p>
	 * The PRNG will not be able to generate random data until sufficient entropy has accumulated for the generator to
	 * be reseeded.  The ability to reseed can be tested with {@link #canReseed()}.
	 * </p>
	 */

	public FortunaAes256()
	{
		this((byte[])null);
	}

	//------------------------------------------------------------------

	/**
	 * Creates a Fortuna/AES-256 pseudo-random number generator that is initialised with the specified seed.
	 * <p>
	 * If the seed is {@code null}, a random seed derived from the sources of entropy will be used.  In this case, the
	 * PRNG will not be able to generate random data until sufficient entropy has accumulated for the generator to be
	 * reseeded.  The ability to reseed can be tested with {@link #canReseed()}.
	 * </p>
	 *
	 * @param seed
	 *          a sequence of bytes that will be used to seed the pseudo-random number generator.  If {@code seed} is
	 *          {@code null}, a random seed derived from the sources of entropy will be used.
	 */

	public FortunaAes256(byte[] seed)
	{
		// Call superclass constructor
		super(Aes256.KEY_SIZE, Aes256.BLOCK_SIZE, seed);
	}

	//------------------------------------------------------------------

	/**
	 * Creates a Fortuna/AES-256 pseudo-random number generator that is initialised with the specified seed in the form
	 * of a string.
	 *
	 * @param seed
	 *          a string whose UTF-8 encoding will be used to seed the pseudo-random number generator.
	 */

	public FortunaAes256(String seed)
	{
		this(keyStringToBytes(seed));
	}

	//------------------------------------------------------------------

////////////////////////////////////////////////////////////////////////
//  Class methods
////////////////////////////////////////////////////////////////////////


	/**
	 * Creates an object that will combine data and random data generated by a PRNG with an exclusive-OR operation.
	 * <p>
	 * The PRNG is created by this method and initialised with the specified seed.  If the seed is {@code null}, a
	 * random seed derived from the sources of entropy will be used.  In this case, the PRNG will not be able to
	 * generate random data until sufficient entropy has accumulated for the generator to be reseeded.  The ability to
	 * reseed can be tested with the {@link Fortuna#canReseed() canReseed()} method of the PRNG that is returned by
	 * {@link Fortuna.XorCombiner#getPrng()}.
	 * </p>
	 *
	 * @param  seed
	 *           the seed that will be used to initialise the PRNG that will generate the random data for the
	 *           exclusive-OR operation.  If {@code seed} is {@code null}, a random seed derived from the sources of
	 *           entropy will be used.
	 * @param  blockSize
	 *           the number of bytes of random data that will be extracted from this object's PRNG with each request.
	 * @return an exclusive-OR combiner object.
	 * @throws IllegalArgumentException
	 *           if {@code blockSize} is less than 1 or greater than 2<sup>20</sup> (1048576).
	 */

	public static XorCombiner createCombiner(byte[] seed,
											 int    blockSize)
	{
		return new XorCombiner(new FortunaAes256(seed), blockSize);
	}

	//------------------------------------------------------------------

////////////////////////////////////////////////////////////////////////
//  Instance methods : overriding methods
////////////////////////////////////////////////////////////////////////

	/**
	 * Creates a copy of this PRNG.
	 * <p>
	 * The copy is initially identical to this object (it has the same state and entropy pools), but the two objects are
	 * independent.
	 * </p>
	 *
	 * @return a copy of this PRNG.
	 */

	@Override
	public FortunaAes256 clone()
	{
		FortunaAes256 copy = (FortunaAes256)super.clone();
		copy.cipher = cipher.clone();
		copy.counter = counter.clone();
		return copy;
	}

	//------------------------------------------------------------------

	/**
	 * Initialises this PRNG's cipher.
	 */

	@Override
	protected void initCipher()
	{
		cipher = new Aes256();
		counter = new byte[Aes256.BLOCK_SIZE];
	}

	//------------------------------------------------------------------

	/**
	 * Resets this PRNG's cipher.
	 */

	@Override
	protected void resetCipher()
	{
		cipher.reset();
		Arrays.fill(counter, (byte)0);
	}

	//------------------------------------------------------------------

	/**
	 * Sets the encryption key of this PRNG's cipher.
	 *
	 * @param key
	 *          the key that will be set as the cipher's encryption key.
	 */

	@Override
	protected void setCipherKey(byte[] key)
	{
		cipher.setEncryptionKey(key);
	}

	//------------------------------------------------------------------

	/**
	 * Increments the block counter of this PRNG's cipher.
	 */

	@Override
	protected void incrementCounter()
	{
		for (int i = 0; i < counter.length; i++)
		{
			if (++counter[i] != 0)
				break;
		}
	}

	//------------------------------------------------------------------

	/**
	 * Encrypts the value of the block counter with this PRNG's cipher and stores the result in the specified buffer.
	 *
	 * @param buffer
	 *          the buffer in which the encrypted data will be stored.
	 * @param offset
	 *          the offset in {@code buffer} at which the first byte of encrypted data will be stored.
	 */

	@Override
	protected void encryptCounter(byte[] buffer,
								  int    offset)
	{
		cipher.encryptBlock(counter, 0, buffer, offset);
	}

	//------------------------------------------------------------------

}

//----------------------------------------------------------------------
