/*====================================================================*\

FortunaChaCha20.java

Class: Fortuna/ChaCha20 pseudo-random number generator.

\*====================================================================*/


// PACKAGE


package uk.blankaspect.common.crypto;

//----------------------------------------------------------------------


// IMPORTS


import java.nio.charset.StandardCharsets;

//----------------------------------------------------------------------


// CLASS: FORTUNA/CHACHA20 PSEUDO-RANDOM NUMBER GENERATOR


/**
 * This class implements the Fortuna pseudo-random number generator (PRNG) algorithm, using a ChaCha20 stream cipher as
 * the underlying generator.
 */

public class FortunaChaCha20
	extends Fortuna
	implements Cloneable
{

////////////////////////////////////////////////////////////////////////
//  Constants
////////////////////////////////////////////////////////////////////////

	/** The size (in bytes) of the PRNG's key, which is the key size of the ChaCha20 cipher. */
	public static final		int		KEY_SIZE	= ChaCha20.KEY_SIZE;

	/** The number of rounds of the ChaCha20 cipher. */
	private static final	int		NUM_ROUNDS	= 20;

	/** The nonce (initialisation vector) of the ChaCha20 cipher. */
	private static final	byte[]	NONCE	= "OrffOFortuna".getBytes(StandardCharsets.US_ASCII);

////////////////////////////////////////////////////////////////////////
//  Instance variables
////////////////////////////////////////////////////////////////////////

	private	ChaCha20	cipher;
	private	long		counter;

////////////////////////////////////////////////////////////////////////
//  Constructors
////////////////////////////////////////////////////////////////////////

	/**
	 * Creates a Fortuna/ChaCha20 pseudo-random number generator that is initialised with a random seed derived from the
	 * sources of entropy.
	 * <p>
	 * The PRNG will not be able to generate random data until sufficient entropy has accumulated for the generator to
	 * be reseeded.  The ability to reseed can be tested with {@link #canReseed()}.
	 * </p>
	 */

	public FortunaChaCha20()
	{
		// Call alternative constructor
		this((byte[])null);
	}

	//------------------------------------------------------------------

	/**
	 * Creates a Fortuna/ChaCha20 pseudo-random number generator that is initialised with the specified seed.
	 * <p>
	 * If the seed is {@code null}, a random seed derived from the sources of entropy will be used.  In this case, the
	 * PRNG will not be able to generate random data until sufficient entropy has accumulated for the generator to be
	 * reseeded.  The ability to reseed can be tested with {@link #canReseed()}.
	 * </p>
	 *
	 * @param seed
	 *          a sequence of bytes that will be used to seed the pseudo-random number generator.  If {@code seed} is
	 *          {@code null}, a random seed derived from the sources of entropy will be used.
	 */

	public FortunaChaCha20(
		byte[]	seed)
	{
		// Call superclass constructor
		super(ChaCha20.KEY_SIZE, ChaCha20.BLOCK_SIZE, seed);
	}

	//------------------------------------------------------------------

	/**
	 * Creates a Fortuna/ChaCha20 pseudo-random number generator that is initialised with the specified seed in the form
	 * of a string.
	 *
	 * @param seed
	 *          a string whose UTF-8 encoding will be used to seed the pseudo-random number generator.
	 */

	public FortunaChaCha20(
		String	seed)
	{
		// Call alternative constructor
		this(keyStringToBytes(seed));
	}

	//------------------------------------------------------------------

////////////////////////////////////////////////////////////////////////
//  Class methods
////////////////////////////////////////////////////////////////////////


	/**
	 * Creates and returns a new instance of an object that can be used to combine data and random data generated by a
	 * PRNG with an exclusive-OR operation.
	 * <p>
	 * The PRNG is created by this method and initialised with the specified seed.  If the seed is {@code null}, a
	 * random seed derived from the sources of entropy will be used.  In this case, the PRNG will not be able to
	 * generate random data until sufficient entropy has accumulated for the generator to be reseeded.  The ability to
	 * reseed can be tested with the {@link Fortuna#canReseed() canReseed()} method of the PRNG that is returned by
	 * {@link Fortuna.XorCombiner#getPrng()}.
	 * </p>
	 *
	 * @param  seed
	 *           the seed that will be used to initialise the PRNG that will generate the random data for the
	 *           exclusive-OR operation.  If {@code seed} is {@code null}, a random seed derived from the sources of
	 *           entropy will be used.
	 * @param  blockSize
	 *           the number of bytes of random data that will be extracted from this object's PRNG with each request.
	 * @return an exclusive-OR combiner object.
	 * @throws IllegalArgumentException
	 *           if {@code blockSize} is less than 1 or greater than 2<sup>20</sup> (1048576).
	 */

	public static XorCombiner combiner(
		byte[]	seed,
		int		blockSize)
	{
		return new XorCombiner(new FortunaChaCha20(seed), blockSize);
	}

	//------------------------------------------------------------------

////////////////////////////////////////////////////////////////////////
//  Instance methods : overriding methods
////////////////////////////////////////////////////////////////////////

	/**
	 * Creates a copy of this PRNG.
	 * <p>
	 * The copy is initially identical to this object (it has the same state and entropy pools), but the two objects are
	 * independent.
	 * </p>
	 *
	 * @return a copy of this PRNG.
	 */

	@Override
	public FortunaChaCha20 clone()
	{
		FortunaChaCha20 copy = (FortunaChaCha20)super.clone();
		copy.cipher = cipher.clone();
		return copy;
	}

	//------------------------------------------------------------------

	/**
	 * Initialises this PRNG's cipher.
	 */

	@Override
	protected void initCipher()
	{
		cipher = new ChaCha20(NUM_ROUNDS);
	}

	//------------------------------------------------------------------

	/**
	 * Resets this PRNG's cipher.
	 */

	@Override
	protected void resetCipher()
	{
		cipher.reset();
		counter = 0;
	}

	//------------------------------------------------------------------

	/**
	 * Sets the encryption key of this PRNG's cipher.
	 *
	 * @param key
	 *          the key that will be set as the cipher's encryption key.
	 */

	@Override
	protected void setCipherKey(
		byte[]	key)
	{
		cipher.init(key, NONCE);
	}

	//------------------------------------------------------------------

	/**
	 * Increments the block counter of this PRNG's cipher.
	 */

	@Override
	protected void incrementCounter()
	{
		++counter;
	}

	//------------------------------------------------------------------

	/**
	 * Encrypts the value of the block counter with this PRNG's cipher and stores the result in the specified buffer.
	 *
	 * @param buffer
	 *          the buffer in which the encrypted data will be stored.
	 * @param offset
	 *          the offset in {@code buffer} at which the first byte of encrypted data will be stored.
	 */

	@Override
	protected void encryptCounter(
		byte[]	buffer,
		int		offset)
	{
		cipher.getBlock(counter, buffer, offset);
	}

	//------------------------------------------------------------------

}

//----------------------------------------------------------------------
